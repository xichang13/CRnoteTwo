- [应用数据和文件](#应用数据和文件)
  - [应用专属存储空间](#应用专属存储空间)
    - [从内部存储空间访问](#从内部存储空间访问)
    - [从外部存储空间访问](#从外部存储空间访问)
  - [共享存储空间](#共享存储空间)
    - [媒体库](#媒体库)
    - [照片选择器](#照片选择器)
    - [文档和其他文件](#文档和其他文件)

# 应用数据和文件
    https://developer.android.google.cn/guide/topics/data?hl=zh-cn

Android 提供了以下几种保存应用数据的选项：

* 应用专属存储空间：存储仅供应用使用的文件，可以存储到内部存储卷中的专属目录或外部存储空间中的其他专属目录。内部存储空间中的目录保存其他应用不应访问的敏感信息。
* 共享存储：存储可由其他应用访问的文件，包括媒体、文档和其他文件。
* 偏好设置：以键值对形式存储私有原始数据。
* 数据库：使用 Room 持久性库将结构化数据存储在 SQLite 数据库中。

在Android中文件操作的步骤：

* 调用 `context.fileList()` 方法获取文件列表
* 使用 `openFileInput()` 和 `openFileOutput()` 方法打开文件
* 读写文件
  * 使用 `FileInputStream` 和 `FileOutputStream` 获取文件流
  * 使用 `InputStreamReader` 和 `OutputStreamWriter` 以字节流形式读写文件流
  * 使用 `BufferedReader` 和 `BufferedWriter` 以字符流形式读写字节流
* 使用 `close()` 方法关闭文件流
* 使用 `flush()` 方法刷新缓冲区

## 应用专属存储空间
    https://developer.android.google.cn/training/data-storage/app-specific?hl=zh-cn

应用专属文件是应用独有的文件，其他应用无法访问。

Android中资源文件有两种：

* `raw` 目录：存储原始文件，例如音频、视频和图像。
* `assets` 目录：存储应用的资源文件，例如文本文件和数据库文件，需要使用流来读取。

### 从内部存储空间访问
不需要权限，一个目录保存持久性文件，一个目录保存缓存文件。

* 访问文件：
  * `getFilesDir()` 获取内部存储卷中的应用专属目录，文件路径为 `/data/data/<package name>/files`。
  * `getCacheDir()` 获取内部存储卷中的应用专属缓存目录，文件路径为 `/data/data/<package name>/cache`。
  * `getResources().openRawResource(R.raw.file)` 打开 `raw` 目录中的文件。
  * `getAssets().open("file")` 打开 `assets` 目录中的文件。

``` Java
// 创建和写入文件
File file = new File(getFilesDir(), "test.txt");
try {
    FileOutputStream outputStream = new FileOutputStream(file);
    OutputStreamWriter writer = new OutputStreamWriter(outputStream);
    BufferedWriter bufferedWriter = new BufferedWriter(writer);

    bufferedWriter.write("Hello World");
    bufferedWriter.newLine();
    bufferedWriter.flush();
    bufferedWriter.close();
} catch (IOException e) {
    e.printStackTrace();
}

// 读取文件
File file = new File(getFilesDir(), "test.txt");
try {
    FileInputStream inputStream = new FileInputStream(file);
    InputStreamReader reader = new InputStreamReader(inputStream);
    BufferedReader bufferedReader = new BufferedReader(reader);

    String line;
    while ((line = bufferedReader.readLine())!= null) {
        Log.v("File", line);
    }
    bufferedReader.close();
} catch (IOException e) {
    e.printStackTrace();
}
```

### 从外部存储空间访问

确定外部存储卷是否可用：
``` Java
// 检查外部存储卷是否可用
if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
    // 外部存储卷可用
} else {
    // 外部存储卷不可用
}
```

* 访问文件：
  * `getExternalFilesDir()` 获取外部存储卷中的应用专属目录，文件路径为 `/sdcard/Android/data/<package name>/files`。
  * `getExternalCacheDir()` 获取外部存储卷中的应用专属缓存目录，文件路径为 `/sdcard/Android/data/<package name>/cache`。

## 共享存储空间
    https://developer.android.google.cn/training/data-storage/shared?hl=zh-cn

如果用户数据可以由其他应用访问，并且卸载应用时不删除数据，则应使用共享存储空间。

Android提供了以下几种共享存储空间：

* 媒体存储：存储媒体文件，例如图像、视频和音频。
* 文档和其他文件：存储应用的文档和其他文件，例如 PDF、CSV 和 XML 文件。
* 数据集和数据库：存储结构化数据，例如联系人、日历事件和电子邮件。

### 媒体库

如需与媒体库交互，需要使用从应用上下文获取的 `ContentResolver` 对象：

``` Java
// 获取 ContentResolver 对象
ContentResolver resolver = getApplicationContext().getContentResolver();

// 查询照片库
String[] projection = {MediaStore.Images.Media._ID, MediaStore.Images.Media.DISPLAY_NAME};
Cursor cursor = resolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, projection, null, null, null);

// 遍历结果
while (cursor.moveToNext()) {
    String id = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID));
    String name = cursor.getString(cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME));
    Log.v("Media", id + " " + name);
}

// 关闭游标
cursor.close();

// 插入照片
ContentValues values = new ContentValues();
values.put(MediaStore.Images.Media.DISPLAY_NAME, "test.jpg");
values.put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg");
values.put(MediaStore.Images.Media.RELATIVE_PATH, "Pictures");
Uri uri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values);

// 打开照片
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.setDataAndType(uri, "image/*");
startActivity(intent);

// 删除照片
resolver.delete(uri, null, null);
```

系统会自动扫描新文件并将其添加到媒体库中：

* 图片（包括照片和屏幕截图），存储在 `DCIM/` 和 `Pictures/` 目录中。系统将这些文件添加到 `MediaStore.Images` 表中。
* 视频，存储在 `DCIM/` 、 `Movies/` 和 `Pictures/` 目录中。系统将这些文件添加到 `MediaStore.Video` 表中。
* 音频文件，存储在 `Alarms/` 、 `Music/` 、 `Notifications/` 和 `Ringtones/` 目录中。系统将这些文件添加到 `MediaStore.Audio` 表中。
* 下载的文件，存储在 `Download/` 目录中。系统将这些文件添加到 `MediaStore.Downloads` 表中。

媒体库还包含一个名为 `MediaStore.Files` 的集合，它包含所有媒体文件的列表。如果需要查看其他应用的媒体文件，则需要声明 `READ_EXTERNAL_STORAGE` 权限。

请求权限：访问自己存储在媒体库中的媒体不需要请求权限，访问其他应用存储在媒体库中的媒体需要请求权限，并且媒体必须在媒体库中。

``` XML
<!-- 请求图片库权限 -->
<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />

<!-- 请求视频库权限 -->
<uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />

<!-- 请求音频库权限 -->
<uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />

<!-- 请求下载库权限 -->
<uses-permission android:name="android.permission.READ_MEDIA_DOWNLOADS" />

<!-- 请求所有媒体库权限 -->
<uses-permission android:name="android.permission.READ_MEDIA_STORAGE" />
```

### 照片选择器
照片选择器提供了一个 UI 组件，用于选择照片、视频和音频文件。

* 如果照片选择器在设备上不可用，会自动调用 `ACTION_GET_CONTENT` 意图，以允许用户选择文件。
* 启动照片选择器：
  * `PickVisualMedia`， 用于选择单个照片或视频。
  * `PickMultipleVisualMedia`，用于选择多个照片或视频。

``` Java
// 注册单选模式
ActivityResultLauncher<VisualMediaPickerRequest> pickMedia = registerForActivityResult(new PickVisualMedia(), uri -> {
    // 回调在用户选择或退出后调用
    if (uri!= null) {
        Log.d("PhotoPicker", "Selected URI: " + uri);
    } else {
        Log.d("PhotoPicker", "No media selected");
    }
});

// 启动单选模式让用户选择图像和视频
pickMedia.launch(new PickVisualMediaRequest.Builder()
    .setMediaType(VisualMedia.ImageAndVideo.INSTANCE)
    .build());

// 选择图像
pickMedia.launch(new PickVisualMediaRequest.Builder()
        .setMediaType(PickVisualMedia.ImageOnly.INSTANCE)
        .build());

// 选择视频
pickMedia.launch(new PickVisualMediaRequest.Builder()
     .setMediaType(PickVisualMedia.VideoOnly.INSTANCE)
     .build());

// 选择特定类型比如 gif 图片
String mimeType = "image/gif";
pickMedia.launch(new PickVisualMediaRequest.Builder()
        .setMediaType(new PickVisualMedia.SingleMimeType(mimeType))
        .build());

// 注册多选模式
ActivityResultLauncher<PickVisualMediaRequest> pickMultipleMedia =
        registerForActivityResult(new PickMultipleVisualMedia(5), uris -> {
    if (!uris.isEmpty()) {
        Log.d("PhotoPicker", "Number of items selected: " + uris.size());
    } else {
        Log.d("PhotoPicker", "No media selected");
    }
});

// 启动多选模式让用户选择图像和视频
pickMultipleMedia.launch(new PickVisualMediaRequest.Builder()
        .setMediaType(PickVisualMedia.ImageAndVideo.INSTANCE)
        .build());
```

### 文档和其他文件
